// PDF generation using browser-native approach (no heavy dependencies)
// For server-side, we generate HTML that can be converted to PDF

export interface ContentForExport {
  title: string
  body: string
  contentType: string
  createdAt: string
  businessName?: string
  metadata?: Record<string, any>
}

export interface ExportOptions {
  format: 'pdf' | 'html' | 'markdown' | 'docx'
  includeMetadata?: boolean
  includeBranding?: boolean
}

// Generate HTML document for PDF conversion
export function generatePDFHTML(
  content: ContentForExport,
  options: ExportOptions = { format: 'pdf', includeBranding: true }
): string {
  const date = new Date(content.createdAt).toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  })

  const typeLabels: Record<string, string> = {
    blog: 'Blog Post',
    social: 'Social Media Post',
    gmb: 'Google Business Post',
    email: 'Email Content',
  }

  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${escapeHtml(content.title)}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Georgia', 'Times New Roman', serif;
      line-height: 1.8;
      color: #1a1a1a;
      max-width: 800px;
      margin: 0 auto;
      padding: 60px 40px;
    }
    .header {
      border-bottom: 2px solid #2563eb;
      padding-bottom: 20px;
      margin-bottom: 40px;
    }
    .logo {
      font-size: 14px;
      color: #2563eb;
      font-weight: bold;
      letter-spacing: 1px;
      margin-bottom: 30px;
    }
    h1 {
      font-size: 32px;
      line-height: 1.3;
      color: #111;
      margin-bottom: 15px;
    }
    .meta {
      font-size: 14px;
      color: #666;
    }
    .meta span {
      margin-right: 20px;
    }
    .type-badge {
      display: inline-block;
      background: #e0e7ff;
      color: #3730a3;
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
    }
    .content {
      font-size: 16px;
      margin-top: 40px;
    }
    .content p {
      margin-bottom: 20px;
    }
    .content h2 {
      font-size: 24px;
      margin: 30px 0 15px;
      color: #111;
    }
    .content h3 {
      font-size: 20px;
      margin: 25px 0 12px;
      color: #333;
    }
    .content ul, .content ol {
      margin: 15px 0 15px 30px;
    }
    .content li {
      margin-bottom: 8px;
    }
    .content blockquote {
      border-left: 4px solid #2563eb;
      padding-left: 20px;
      margin: 20px 0;
      color: #555;
      font-style: italic;
    }
    .hashtags {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 1px solid #e5e5e5;
    }
    .hashtag {
      display: inline-block;
      background: #f3f4f6;
      color: #4b5563;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 13px;
      margin-right: 8px;
      margin-bottom: 8px;
    }
    .footer {
      margin-top: 60px;
      padding-top: 20px;
      border-top: 1px solid #e5e5e5;
      font-size: 12px;
      color: #999;
      text-align: center;
    }
    @media print {
      body { padding: 40px 30px; }
      .no-print { display: none; }
    }
  </style>
</head>
<body>
  <div class="header">
    ${options.includeBranding ? '<div class="logo">LOCALCONTENT.AI</div>' : ''}
    <h1>${escapeHtml(content.title)}</h1>
    <div class="meta">
      <span class="type-badge">${typeLabels[content.contentType] || content.contentType}</span>
      <span>Created: ${date}</span>
      ${content.businessName ? `<span>For: ${escapeHtml(content.businessName)}</span>` : ''}
    </div>
  </div>
  
  <div class="content">
    ${formatContentBody(content.body)}
  </div>
  
  ${content.metadata?.hashtags?.length ? `
    <div class="hashtags">
      ${content.metadata.hashtags.map((tag: string) => `<span class="hashtag">#${escapeHtml(tag)}</span>`).join('')}
    </div>
  ` : ''}
  
  ${options.includeBranding ? `
    <div class="footer">
      Generated by LocalContent.ai â€¢ ${date}
    </div>
  ` : ''}
</body>
</html>
  `.trim()
}

// Generate Markdown export
export function generateMarkdown(content: ContentForExport): string {
  const date = new Date(content.createdAt).toISOString().split('T')[0]
  
  let md = `# ${content.title}\n\n`
  md += `**Type:** ${content.contentType}\n`
  md += `**Created:** ${date}\n`
  if (content.businessName) {
    md += `**Business:** ${content.businessName}\n`
  }
  md += `\n---\n\n`
  md += content.body
  
  if (content.metadata?.hashtags?.length) {
    md += `\n\n---\n\n**Tags:** ${content.metadata.hashtags.map((t: string) => `#${t}`).join(' ')}`
  }
  
  return md
}

// Generate plain text export
export function generatePlainText(content: ContentForExport): string {
  let text = `${content.title}\n${'='.repeat(content.title.length)}\n\n`
  text += `Type: ${content.contentType}\n`
  text += `Created: ${new Date(content.createdAt).toLocaleDateString()}\n`
  if (content.businessName) {
    text += `Business: ${content.businessName}\n`
  }
  text += `\n${'-'.repeat(40)}\n\n`
  text += stripHtml(content.body)
  
  if (content.metadata?.hashtags?.length) {
    text += `\n\n${'-'.repeat(40)}\nTags: ${content.metadata.hashtags.map((t: string) => `#${t}`).join(' ')}`
  }
  
  return text
}

// Generate Word-compatible HTML (can be opened in Word)
export function generateWordHTML(content: ContentForExport): string {
  const html = generatePDFHTML(content, { format: 'docx', includeBranding: false })
  
  // Add Word-specific meta tags
  return html.replace('<head>', `<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <!--[if gte mso 9]>
    <xml>
      <o:OfficeDocumentSettings>
        <o:AllowPNG/>
      </o:OfficeDocumentSettings>
    </xml>
    <![endif]-->`)
}

// Batch export multiple content items
export function generateBatchExport(
  contents: ContentForExport[],
  format: 'markdown' | 'text'
): string {
  const separator = format === 'markdown' ? '\n\n---\n\n' : '\n\n' + '='.repeat(60) + '\n\n'
  
  return contents.map(content => 
    format === 'markdown' 
      ? generateMarkdown(content)
      : generatePlainText(content)
  ).join(separator)
}

// Helper functions
function escapeHtml(text: string): string {
  const map: Record<string, string> = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#039;',
  }
  return text.replace(/[&<>"']/g, m => map[m])
}

function stripHtml(html: string): string {
  return html
    .replace(/<[^>]*>/g, '')
    .replace(/&nbsp;/g, ' ')
    .replace(/&amp;/g, '&')
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&quot;/g, '"')
    .trim()
}

function formatContentBody(body: string): string {
  // If already HTML, return as-is
  if (body.includes('<p>') || body.includes('<div>')) {
    return body
  }
  
  // Convert plain text/markdown to HTML
  return body
    .split('\n\n')
    .map(para => {
      // Headers
      if (para.startsWith('## ')) return `<h2>${escapeHtml(para.slice(3))}</h2>`
      if (para.startsWith('### ')) return `<h3>${escapeHtml(para.slice(4))}</h3>`
      if (para.startsWith('# ')) return `<h2>${escapeHtml(para.slice(2))}</h2>`
      
      // Lists
      if (para.match(/^[-*] /m)) {
        const items = para.split('\n').filter(l => l.trim())
        return `<ul>${items.map(i => `<li>${escapeHtml(i.replace(/^[-*] /, ''))}</li>`).join('')}</ul>`
      }
      
      // Regular paragraph
      return `<p>${escapeHtml(para).replace(/\n/g, '<br>')}</p>`
    })
    .join('\n')
}
